; a deque node is (list content prev next)
(define (make-node content prev next) (list content prev next))
(define (content node) (car node))
(define (prev node) (cadr node))
(define (next node) (caddr node))
(define (set-prev! node prev) (set-car! (cdr node) prev))
(define (set-next! node next) (set-car! (cddr node) next))

; a deque is (front node, rear node)
(define (make-deque) (cons '() '()))
(define (front-ptr deq) (car deq))
(define (rear-ptr deq) (cdr deq))
(define (set-front-ptr! deq front) (set-car! deq front))
(define (set-rear-ptr! deq rear) (set-cdr! deq rear))
(define (empty-deque? deq) (null? (front-ptr deq)))
(define (front-deque deq)
    (if (empty-deque? deq)
        (error "FRONT called with an empty deque")
        (content (front-ptr deq))))
(define (rear-deque deq)
    (if (empty-deque? deq)
        (error "REAR called with an empty deque")
        (content (rear-ptr deq))))
(define (front-insert-deque! deq item)
    (let ((new-node (make-node item '() '())))
        (cond ((empty-deque? deq)
               (set-front-ptr! deq new-node)
               (set-rear-ptr! deq new-node))
              (else
               (set-prev! (front-ptr deq) new-node)
               (set-next! new-node (front-ptr deq))
               (set-front-ptr! deq new-node)))))
(define (rear-insert-deque! deq item)
    (let ((new-node (make-node item '() '())))
        (cond ((empty-deque? deq)
               (set-front-ptr! deq new-node)
               (set-rear-ptr! deq new-node))
              (else 
               (set-next! (rear-ptr deq) new-node)
               (set-prev! new-node (rear-ptr deq))
               (set-rear-ptr! deq new-node)))))
(define (front-delete-deque! deq)
    (cond ((empty-deque? deq)
           (error "FRONT-DELETE called with an empty deque")
           deq)
          ((null? (next (front-ptr deq)))
           (set-front-ptr! deq '())
           (set-rear-ptr! deq '()))
          (else
           (set-front-ptr! deq (next (front-ptr deq)))
           (set-prev! (front-ptr deq) '()))))
(define (rear-delete-deque! deq)
    (cond ((empty-deque? deq)
           (error "REAR-DELETE called with an empty deque")
           deq)
          ((null? (prev (rear-ptr deq)))
           (set-front-ptr! deq '())
           (set-rear-ptr! deq '()))
          (else
           (set-rear-ptr! deq (prev (rear-ptr deq)))
           (set-next! (rear-ptr deq) '()))))
(define (print-deque deq)
    (define (to-list node)
        (if (null? node)
            '()
            (cons (content node) (to-list (next node)))))
    (display (to-list (front-ptr deq))))

; test
(define d (make-deque))
(print-deque d)
(front-insert-deque! d 1)
(print-deque d)
(rear-insert-deque! d 2)
(print-deque d)
(front-insert-deque! d 3)
(print-deque d)
(rear-delete-deque! d)
(print-deque d)
(front-delete-deque! d)
(print-deque d)
(front-delete-deque! d)
(print-deque d)
(front-delete-deque! d) ; delete on empty
(print-deque d)
